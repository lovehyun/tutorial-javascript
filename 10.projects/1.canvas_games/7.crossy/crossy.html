<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>길건너 게임</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 3px solid #fff;
            background: #4a7c59;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        #score {
            color: white;
            font-size: 24px;
            margin-top: 20px;
            font-weight: bold;
        }
        
        #gameOver {
            color: #ff6b6b;
            font-size: 32px;
            margin-top: 10px;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        <div id="score">점수: 0</div>
        <div id="gameOver">게임 오버! R키로 재시작</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const GRID_SIZE = 50;
        const COLS = canvas.width / GRID_SIZE;
        const ROWS = canvas.height / GRID_SIZE;
        
        let player = { x: 4, worldY: 10 };
        let lanes = [];
        let worldOffset = 0;
        let gameRunning = true;
        let keyPressed = false;
        
        function createLane(worldY, forceSafe = false) {
            const type = forceSafe ? 0 : (Math.random() > 0.4 ? (Math.random() > 0.5 ? 1 : 2) : 0);
            const lane = {
                worldY: worldY,
                type: type,
                cars: []
            };
            
            if (type > 0) {
                const numCars = 2 + Math.floor(Math.random() * 3);
                const speed = 0.01 + Math.random() * 0.015;
                const gap = COLS / numCars;
                
                for (let i = 0; i < numCars; i++) {
                    lane.cars.push({
                        x: i * gap + Math.random() * gap * 0.5,
                        speed: speed,
                        direction: type === 1 ? -1 : 1
                    });
                }
            }
            
            return lane;
        }
        
        for (let i = -10; i <= 15; i++) {
            const isSafeZone = i >= 8 && i <= 12;
            lanes.push(createLane(i, isSafeZone));
        }
        
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) {
                if (e.key === 'r') resetGame();
                return;
            }
            
            if (keyPressed) return;
            keyPressed = true;
            
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                player.x = Math.max(0, player.x - 1);
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                player.x = Math.min(COLS - 1, player.x + 1);
            } else if (e.key === 'ArrowUp' || e.key === 'w') {
                const newScreenY = (player.worldY - 1 - worldOffset) * GRID_SIZE;
                if (newScreenY >= 0) {
                    player.worldY -= 1;
                }
            } else if (e.key === 'ArrowDown' || e.key === 's') {
                const newScreenY = (player.worldY + 1 - worldOffset) * GRID_SIZE;
                if (newScreenY < canvas.height - GRID_SIZE) {
                    player.worldY += 1;
                }
            }
            
            setTimeout(() => { keyPressed = false; }, 150);
        });
        
        function update() {
            if (!gameRunning) return;
            
            worldOffset -= 0.015;
            
            if (lanes[0].worldY - worldOffset < -2) {
                lanes.shift();
                lanes.unshift(createLane(lanes[0].worldY - 1, false));
            }
            
            if (lanes[lanes.length - 1].worldY - worldOffset > ROWS + 2) {
                lanes.pop();
                lanes.push(createLane(lanes[lanes.length - 1].worldY + 1, false));
            }
            
            lanes.forEach(lane => {
                lane.cars.forEach(car => {
                    car.x += car.speed * car.direction;
                    
                    if (car.direction === 1 && car.x > COLS + 2) {
                        car.x = -2;
                    } else if (car.direction === -1 && car.x < -2) {
                        car.x = COLS + 2;
                    }
                });
            });
            
            const playerLane = lanes.find(lane => 
                Math.abs(lane.worldY - player.worldY) < 0.5
            );
            
            if (playerLane && playerLane.type > 0) {
                playerLane.cars.forEach(car => {
                    if (Math.abs(car.x - player.x) < 0.8) {
                        gameOver();
                    }
                });
            }
            
            const playerScreenY = (player.worldY - worldOffset) * GRID_SIZE;
            if (playerScreenY >= canvas.height - GRID_SIZE) {
                gameOver();
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            lanes.forEach(lane => {
                const screenY = (lane.worldY - worldOffset) * GRID_SIZE;
                
                if (screenY < -GRID_SIZE || screenY > canvas.height) return;
                
                if (lane.type === 0) {
                    ctx.fillStyle = '#4a7c59';
                } else {
                    ctx.fillStyle = '#3a3a3a';
                }
                ctx.fillRect(0, screenY, canvas.width, GRID_SIZE);
                
                if (lane.type > 0) {
                    ctx.strokeStyle = '#ffeb3b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, screenY + GRID_SIZE / 2);
                    ctx.lineTo(canvas.width, screenY + GRID_SIZE / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                lane.cars.forEach(car => {
                    const carX = car.x * GRID_SIZE;
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(carX, screenY + 10, GRID_SIZE - 5, GRID_SIZE - 20);
                });
            });
            
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            const px = player.x * GRID_SIZE;
            const py = (player.worldY - worldOffset) * GRID_SIZE;
            
            ctx.fillStyle = '#3498db';
            ctx.fillRect(px + 5, py + 5, GRID_SIZE - 10, GRID_SIZE - 10);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(px + 5, py + 5, GRID_SIZE - 10, GRID_SIZE - 10);
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function resetGame() {
            player = { x: 4, worldY: 10 };
            lanes = [];
            for (let i = -10; i <= 15; i++) {
                const isSafeZone = i >= 8 && i <= 12;
                lanes.push(createLane(i, isSafeZone));
            }
            worldOffset = 0;
            gameRunning = true;
            keyPressed = false;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function gameLoop() {
            update();
            draw();
            const score = Math.max(0, Math.floor(10 - player.worldY));
            document.getElementById('score').textContent = `점수: ${score}`;
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>

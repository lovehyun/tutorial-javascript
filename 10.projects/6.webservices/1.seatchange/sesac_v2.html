<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>새싹 좌석 배치 랜덤 셔플 + 편집 모드</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f5f7fb;
            color: #222;
        }
        .container {
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        .panel {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
            padding: 20px;
        }
        .left-panel {
            width: 340px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        h1 {
            font-size: 20px;
            margin: 0 0 6px;
        }
        .subtitle {
            font-size: 12px;
            color: #666;
        }
        label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
            display: inline-block;
        }
        select {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 14px;
        }
        .names-list {
            max-height: 260px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid #eee;
            padding: 8px;
            background: #fafbff;
        }
        .name-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }
        .name-row span {
            font-size: 12px;
            width: 40px;
            text-align: right;
            color: #555;
        }
        .name-row input {
            flex: 1;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 13px;
        }
        .buttons {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }
        button {
            flex: 1;
            padding: 8px 10px;
            border-radius: 999px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
        }
        button.primary {
            background: #4f46e5;
            color: white;
        }
        button.secondary {
            background: #e5e7eb;
            color: #111827;
        }
        button.ghost {
            flex: 0 0 auto;
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }
        button.ghost.on {
            background: #dcfce7;
            border-color: #16a34a;
            color: #166534;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .hint {
            font-size: 11px;
            color: #777;
            line-height: 1.4;
        }
        canvas {
            width: 100%;
            max-width: 900px;
            border-radius: 12px;
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
        }
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .canvas-title {
            font-size: 14px;
            color: #555;
        }
        .edit-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
        }
        .edit-badge.on {
            border-color: #16a34a;
            background: #dcfce7;
            color: #166534;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="panel left-panel">
        <div>
            <h1>좌석 배치 랜덤 셔플</h1>
            <div class="subtitle">새싹(Seoul SW Academy) 웹서비스 개발자 과정</div>
        </div>

        <div>
            <label for="roomSelect">교육장 선택</label>
            <select id="roomSelect">
                <option value="room10">A 교육장 (10석)</option>
                <option value="room13">B 교육장 (13석)</option>
            </select>
        </div>

        <div>
            <label>수강생 이름 입력</label>
            <div id="namesContainer" class="names-list">
                <!-- 이름 입력칸 자동 생성 -->
            </div>
        </div>

        <div class="buttons">
            <button id="saveNamesBtn" class="secondary">이름 저장</button>
            <button id="shuffleBtn" class="primary">랜덤 섞기</button>
        </div>

        <div>
            <button id="editModeBtn" class="ghost">편집 모드: OFF</button>
        </div>

        <div class="hint">
            · 이름은 브라우저에 <b>localStorage</b>로 저장됩니다.<br>
            · <b>편집 모드 ON</b>에서 좌석 / 강사 / 스크린 / 출입문을 마우스로 드래그해서 바꾸고, 놓는 순간 자동 저장됩니다.<br>
            · 랜덤 섞기 시, 화면 중앙에 룰렛이 돌고, 0.5초마다 한 자리씩 이름이 채워집니다.
        </div>
    </div>

    <div class="panel right-panel">
        <div class="canvas-header">
            <div class="canvas-title" id="canvasTitle">A 교육장 (10석) 도면</div>
            <div class="edit-badge" id="editBadge">편집 모드: OFF</div>
        </div>
        <canvas id="roomCanvas" width="900" height="460"></canvas>
    </div>
</div>

<script>
    // =========================
    // 1. 기본 레이아웃 정의 (기본 좌표)
    // =========================

    const roomLayoutsBase = {
        room10: {
            label: "A 교육장 (10석)",
            seatCount: 10,
            seats: [
                { id: 1, x: 120, y: 120, w: 80, h: 50 },
                { id: 2, x: 220, y: 120, w: 80, h: 50 },
                { id: 3, x: 320, y: 120, w: 80, h: 50 },
                { id: 4, x: 420, y: 120, w: 80, h: 50 },
                { id: 5, x: 520, y: 120, w: 80, h: 50 },

                { id: 6, x: 120, y: 200, w: 80, h: 50 },
                { id: 7, x: 220, y: 200, w: 80, h: 50 },
                { id: 8, x: 320, y: 200, w: 80, h: 50 },
                { id: 9, x: 420, y: 200, w: 80, h: 50 },
                { id: 10,x: 520, y: 200, w: 80, h: 50 }
            ],
            instructor: { x: 360, y: 40, w: 90, h: 40 },
            screen:    { x: 220, y: 10, w: 260, h: 20 },
            door:      { x: 820, y: 260, w: 40, h: 90 }
        },
        room13: {
            label: "B 교육장 (13석)",
            seatCount: 13,
            seats: [
                { id: 1, x: 80,  y: 120, w: 80, h: 50 },
                { id: 2, x: 180, y: 120, w: 80, h: 50 },
                { id: 3, x: 280, y: 120, w: 80, h: 50 },
                { id: 4, x: 380, y: 120, w: 80, h: 50 },
                { id: 5, x: 480, y: 120, w: 80, h: 50 },

                { id: 6, x: 80,  y: 200, w: 80, h: 50 },
                { id: 7, x: 180, y: 200, w: 80, h: 50 },
                { id: 8, x: 280, y: 200, w: 80, h: 50 },
                { id: 9, x: 380, y: 200, w: 80, h: 50 },
                { id: 10,x: 480, y: 200, w: 80, h: 50 },

                { id: 11,x: 130, y: 280, w: 80, h: 50 },
                { id: 12,x: 280, y: 280, w: 80, h: 50 },
                { id: 13,x: 430, y: 280, w: 80, h: 50 }
            ],
            instructor: { x: 360, y: 40, w: 90, h: 40 },
            screen:    { x: 220, y: 10, w: 260, h: 20 },
            door:      { x: 820, y: 260, w: 40, h: 90 }
        }
    };

    // =========================
    // 2. 상태 변수 정의
    // =========================

    const roomSelect     = document.getElementById('roomSelect');
    const namesContainer = document.getElementById('namesContainer');
    const saveNamesBtn   = document.getElementById('saveNamesBtn');
    const shuffleBtn     = document.getElementById('shuffleBtn');
    const editModeBtn    = document.getElementById('editModeBtn');
    const canvas         = document.getElementById('roomCanvas');
    const ctx            = canvas.getContext('2d');
    const canvasTitle    = document.getElementById('canvasTitle');
    const editBadge      = document.getElementById('editBadge');

    let currentRoomKey    = 'room10';
    let currentLayout     = null;   // 좌표(도면 레이아웃)
    let currentAssignments= {};     // 좌석 배정 { seatId: name }
    let editMode          = false;  // 편집 모드 여부

    // 애니메이션 상태
    let isAnimating      = false;
    let spinnerAngle     = 0;
    let spinnerStartTime = 0;
    let spinnerDuration  = 1500;   // 룰렛 도는 시간(ms)
    let spinnerReqId     = null;
    let revealTimerId    = null;
    let pendingAssignments = [];

    // 드래그 상태
    let dragTarget = null;   // { type, obj }  type: 'seat'|'screen'|'door'|'instructor'
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let isMouseDown = false;

    // =========================
    // 3. localStorage 유틸리티
    // =========================

    function getNamesStorageKey(roomKey) {
        return 'seatApp_names_' + roomKey;
    }
    function getLayoutStorageKey(roomKey) {
        return 'seatApp_layout_' + roomKey;   // 좌표 정보 저장용
    }
    function getAssignStorageKey(roomKey) {
        return 'seatApp_assign_' + roomKey;   // 좌석 배정 정보 저장용
    }

    // 이름 리스트 저장/로드
    function loadNames(roomKey) {
        const raw = localStorage.getItem(getNamesStorageKey(roomKey));
        if (!raw) return [];
        try {
            const arr = JSON.parse(raw);
            return Array.isArray(arr) ? arr : [];
        } catch (e) {
            return [];
        }
    }

    function saveNames(roomKey, names) {
        localStorage.setItem(getNamesStorageKey(roomKey), JSON.stringify(names));
    }

    // 좌석/스크린/문/강사 좌표 저장/로드
    function loadLayout(roomKey) {
        const raw = localStorage.getItem(getLayoutStorageKey(roomKey));
        if (!raw) return null;
        try {
            const obj = JSON.parse(raw);
            return obj && typeof obj === 'object' ? obj : null;
        } catch (e) {
            return null;
        }
    }

    function saveLayout(roomKey, layout) {
        // 현재 레이아웃에서 필요한 정보만 저장
        const data = {
            seats: layout.seats.map(s => ({
                id: s.id, x: s.x, y: s.y, w: s.w, h: s.h
            })),
            instructor: {
                x: layout.instructor.x,
                y: layout.instructor.y,
                w: layout.instructor.w,
                h: layout.instructor.h
            },
            screen: {
                x: layout.screen.x,
                y: layout.screen.y,
                w: layout.screen.w,
                h: layout.screen.h
            },
            door: {
                x: layout.door.x,
                y: layout.door.y,
                w: layout.door.w,
                h: layout.door.h
            }
        };
        localStorage.setItem(getLayoutStorageKey(roomKey), JSON.stringify(data));
    }

    // 좌석 배정 정보 저장/로드
    function loadAssignments(roomKey) {
        const raw = localStorage.getItem(getAssignStorageKey(roomKey));
        if (!raw) return {};
        try {
            const obj = JSON.parse(raw);
            return obj && typeof obj === 'object' ? obj : {};
        } catch (e) {
            return {};
        }
    }

    function saveAssignments(roomKey, assignments) {
        localStorage.setItem(getAssignStorageKey(roomKey), JSON.stringify(assignments));
    }

    // =========================
    // 4. 레이아웃 로딩 (기본 + 저장된 좌표 merge)
    // =========================

    function loadLayoutOrDefault(roomKey) {
        const base = roomLayoutsBase[roomKey];
        // base 깊은 복사
        const layout = {
            label: base.label,
            seatCount: base.seatCount,
            seats: base.seats.map(s => ({ ...s })),
            instructor: { ...base.instructor },
            screen: { ...base.screen },
            door: { ...base.door }
        };

        const saved = loadLayout(roomKey);
        if (!saved) return layout;

        // 저장된 좌표가 있으면 반영
        if (Array.isArray(saved.seats)) {
            layout.seats.forEach(seat => {
                const found = saved.seats.find(s => s.id === seat.id);
                if (found) {
                    seat.x = found.x;
                    seat.y = found.y;
                    seat.w = found.w ?? seat.w;
                    seat.h = found.h ?? seat.h;
                }
            });
        }
        if (saved.instructor) {
            layout.instructor.x = saved.instructor.x ?? layout.instructor.x;
            layout.instructor.y = saved.instructor.y ?? layout.instructor.y;
        }
        if (saved.screen) {
            layout.screen.x = saved.screen.x ?? layout.screen.x;
            layout.screen.y = saved.screen.y ?? layout.screen.y;
        }
        if (saved.door) {
            layout.door.x = saved.door.x ?? layout.door.x;
            layout.door.y = saved.door.y ?? layout.door.y;
        }
        return layout;
    }

    // =========================
    // 5. 이름 입력 UI 생성
    // =========================

    function renderNameInputs() {
        const layout = roomLayoutsBase[currentRoomKey]; // seatCount 기준은 base 사용
        const seatCount = layout.seatCount;
        const savedNames = loadNames(currentRoomKey);

        namesContainer.innerHTML = '';

        for (let i = 0; i < seatCount; i++) {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'name-row';

            const labelSpan = document.createElement('span');
            labelSpan.textContent = (i + 1) + '번';

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = '수강생 이름';
            input.value = savedNames[i] || '';

            rowDiv.appendChild(labelSpan);
            rowDiv.appendChild(input);
            namesContainer.appendChild(rowDiv);
        }
    }

    function collectNamesFromInputs() {
        const inputs = namesContainer.querySelectorAll('input');
        const names = [];
        inputs.forEach(input => names.push(input.value.trim()));
        return names;
    }

    // =========================
    // 6. 캔버스 그리기
    // =========================

    function drawRoom() {
        if (!currentLayout) return;
        const layout = currentLayout;
        const seats  = layout.seats;

        // 전체 배경
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f3f4f6';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 교실 외곽
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 2;
        ctx.strokeRect(40, 40, canvas.width - 100, canvas.height - 100);

        // 스크린
        const scr = layout.screen;
        ctx.fillStyle = '#111827';
        ctx.fillRect(scr.x, scr.y, scr.w, scr.h);
        ctx.fillStyle = '#fff';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('스크린', scr.x + scr.w / 2, scr.y + scr.h / 2);

        // 강사석
        const inst = layout.instructor;
        ctx.fillStyle = '#e0f2fe';
        ctx.strokeStyle = '#0284c7';
        ctx.lineWidth = 2;
        ctx.fillRect(inst.x, inst.y, inst.w, inst.h);
        ctx.strokeRect(inst.x, inst.y, inst.w, inst.h);
        ctx.fillStyle = '#111827';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('강사', inst.x + inst.w / 2, inst.y + inst.h / 2);

        // 출입문
        const door = layout.door;
        ctx.fillStyle = '#f97316';
        ctx.fillRect(door.x, door.y, door.w, door.h);
        ctx.fillStyle = '#fff';
        ctx.font = '12px sans-serif';
        ctx.save();
        ctx.translate(door.x + door.w / 2, door.y + door.h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('출입문', 0, 0);
        ctx.restore();

        // 학생 좌석
        seats.forEach(seat => {
            const name = currentAssignments[seat.id] || '';

            // 좌석 박스
            ctx.fillStyle = name ? '#e5fce7' : '#ffffff';
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 1.5;
            ctx.fillRect(seat.x, seat.y, seat.w, seat.h);
            ctx.strokeRect(seat.x, seat.y, seat.w, seat.h);

            // 좌석 번호
            ctx.fillStyle = '#4b5563';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(seat.id + '번', seat.x + 4, seat.y + 3);

            // 이름
            if (name) {
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#111827';
                ctx.fillText(
                    name,
                    seat.x + seat.w / 2,
                    seat.y + seat.h / 2 + 6
                );
            }
        });

        // 편집 모드일 때, 살짝 안내 텍스트
        if (editMode && !isAnimating) {
            ctx.fillStyle = 'rgba(55,65,81,0.7)';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('편집 모드: 요소를 드래그해서 위치를 수정할 수 있습니다.', canvas.width - 10, canvas.height - 10);
        }
    }

    // =========================
    // 7. 랜덤 셔플 + 룰렛 애니메이션
    // =========================

    function fisherYatesShuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    function startShuffle() {
        if (isAnimating) return;

        const base = roomLayoutsBase[currentRoomKey];
        const names = collectNamesFromInputs();
        const seatCount = base.seatCount;

        const filledNames = names.filter(n => n.length > 0);
        if (filledNames.length !== seatCount) {
            alert(`이 교육장은 ${seatCount}명이 필요합니다.\n` +
                  `입력된 이름 수: ${filledNames.length}명\n` +
                  `빈 칸 없이 모두 채워주세요.`);
            return;
        }

        // 이름 저장
        saveNames(currentRoomKey, names);

        // 랜덤 순서 만들기
        const shuffled = fisherYatesShuffle([...filledNames]);

        // 기존 좌석 배정 초기화
        currentAssignments = {};
        drawRoom();

        // 애니메이션 상태 설정
        isAnimating = true;
        spinnerAngle = 0;
        spinnerStartTime = 0;
        pendingAssignments = [];

        // 좌석 id 순서대로 이름 매핑 준비
        const seats = currentLayout.seats;
        seats.forEach((seat, idx) => {
            pendingAssignments.push({
                id: seat.id,
                name: shuffled[idx]
            });
        });

        // 버튼/선택 비활성화
        shuffleBtn.disabled = true;
        saveNamesBtn.disabled = true;
        roomSelect.disabled = true;
        editModeBtn.disabled = true;

        // 룰렛 시작
        spinnerReqId = requestAnimationFrame(spinnerStep);
    }

    function spinnerStep(timestamp) {
        if (!spinnerStartTime) spinnerStartTime = timestamp;
        const elapsed = timestamp - spinnerStartTime;

        // 기본 도면 다시 그림
        drawRoom();

        // 룰렛(원형) 그리기
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = 45;

        spinnerAngle += 0.25;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(spinnerAngle);

        ctx.beginPath();
        ctx.strokeStyle = '#4f46e5';
        ctx.lineWidth = 8;
        ctx.arc(0, 0, radius, 0, Math.PI * 1.5);
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = '#6366f1';
        ctx.moveTo(0, -radius - 8);
        ctx.lineTo(-6, -radius - 20);
        ctx.lineTo(6, -radius - 20);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = '#374151';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('랜덤 섞는 중...', cx, cy + radius + 15);

        if (elapsed < spinnerDuration) {
            spinnerReqId = requestAnimationFrame(spinnerStep);
        } else {
            spinnerStartTime = 0;
            requestAnimationFrame(() => {
                startRevealAnimation();
            });
        }
    }

    function startRevealAnimation() {
        drawRoom(); // 룰렛 제거

        let index = 0;
        const total = pendingAssignments.length;

        revealTimerId = setInterval(() => {
            if (index >= total) {
                clearInterval(revealTimerId);
                revealTimerId = null;
                isAnimating = false;

                // 최종 좌석 배정 저장
                saveAssignments(currentRoomKey, currentAssignments);

                // 버튼/선택 다시 활성화
                shuffleBtn.disabled = false;
                saveNamesBtn.disabled = false;
                roomSelect.disabled = false;
                editModeBtn.disabled = false;
                return;
            }

            const seatAssign = pendingAssignments[index];
            currentAssignments[seatAssign.id] = seatAssign.name;
            drawRoom();
            index++;
        }, 500); // 0.5초마다 한 명씩 표시
    }

    // =========================
    // 8. 드래그 편집 모드 로직
    // =========================

    // 마우스 좌표 → 캔버스 좌표 변환
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }

    // 특정 좌표가 사각형 내부인지 체크
    function isPointInRect(x, y, rect) {
        return x >= rect.x &&
               x <= rect.x + rect.w &&
               y >= rect.y &&
               y <= rect.y + rect.h;
    }

    // 드래그 가능한 객체 찾기 (화면에 가까운 순서대로 검사)
    function hitTest(x, y) {
        if (!currentLayout) return null;
        const layout = currentLayout;

        // 우선순위: 좌석들 → 강사 → 스크린 → 출입문 (마음대로 변경 가능)
        // 좌석은 뒤에 정의된 것이 위에 그려졌다고 가정하고 역순으로 검사해도 됨
        for (let i = layout.seats.length - 1; i >= 0; i--) {
            const seat = layout.seats[i];
            if (isPointInRect(x, y, seat)) {
                return { type: 'seat', obj: seat };
            }
        }
        if (isPointInRect(x, y, layout.instructor)) {
            return { type: 'instructor', obj: layout.instructor };
        }
        if (isPointInRect(x, y, layout.screen)) {
            return { type: 'screen', obj: layout.screen };
        }
        if (isPointInRect(x, y, layout.door)) {
            return { type: 'door', obj: layout.door };
        }
        return null;
    }

    // 드래그 중 위치를 화면 밖으로 안 나가게 간단히 클램프
    function clampObjectToCanvas(obj) {
        obj.x = Math.max(0, Math.min(canvas.width - obj.w, obj.x));
        obj.y = Math.max(0, Math.min(canvas.height - obj.h, obj.y));
    }

    function onMouseDown(evt) {
        if (!editMode || isAnimating) return;

        isMouseDown = true;
        const pos = getMousePos(evt);
        const hit = hitTest(pos.x, pos.y);
        if (hit) {
            dragTarget = hit;
            dragOffsetX = pos.x - hit.obj.x;
            dragOffsetY = pos.y - hit.obj.y;
        }
    }

    function onMouseMove(evt) {
        if (!editMode || isAnimating) return;
        if (!dragTarget || !isMouseDown) return;

        const pos = getMousePos(evt);
        const obj = dragTarget.obj;
        obj.x = pos.x - dragOffsetX;
        obj.y = pos.y - dragOffsetY;
        clampObjectToCanvas(obj);

        drawRoom();
    }

    function onMouseUp() {
        if (!editMode || isAnimating) {
            dragTarget = null;
            isMouseDown = false;
            return;
        }
        if (dragTarget) {
            // 드래그가 끝난 시점에 레이아웃 저장
            saveLayout(currentRoomKey, currentLayout);
        }
        dragTarget = null;
        isMouseDown = false;
    }

    function onMouseLeave() {
        // 캔버스를 벗어나도 드래그 종료 처리
        if (dragTarget) {
            saveLayout(currentRoomKey, currentLayout);
        }
        dragTarget = null;
        isMouseDown = false;
    }

    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('mouseleave', onMouseLeave);

    // =========================
    // 9. 이벤트 핸들러 (UI)
    // =========================

    roomSelect.addEventListener('change', () => {
        currentRoomKey = roomSelect.value;
        const base = roomLayoutsBase[currentRoomKey];
        canvasTitle.textContent = base.label + ' 도면';

        // 레이아웃 / 이름 입력 / 배정 정보 재로딩
        currentLayout = loadLayoutOrDefault(currentRoomKey);
        renderNameInputs();
        currentAssignments = loadAssignments(currentRoomKey) || {};
        drawRoom();
    });

    saveNamesBtn.addEventListener('click', () => {
        const base = roomLayoutsBase[currentRoomKey];
        const names = collectNamesFromInputs();
        const filledNames = names.filter(n => n.length > 0);

        if (filledNames.length !== base.seatCount) {
            if (!confirm(
                `현재 ${base.seatCount}석 중 ${filledNames.length}명만 입력되어 있습니다.\n` +
                `그래도 저장하시겠습니까?`
            )) {
                return;
            }
        }
        saveNames(currentRoomKey, names);
        alert('이름이 이 브라우저(localStorage)에 저장되었습니다.');
    });

    shuffleBtn.addEventListener('click', startShuffle);

    editModeBtn.addEventListener('click', () => {
        if (isAnimating) return;
        editMode = !editMode;
        updateEditModeUI();
        drawRoom();
    });

    function updateEditModeUI() {
        if (editMode) {
            editModeBtn.textContent = '편집 모드: ON';
            editModeBtn.classList.add('on');
            editBadge.textContent = '편집 모드: ON';
            editBadge.classList.add('on');
        } else {
            editModeBtn.textContent = '편집 모드: OFF';
            editModeBtn.classList.remove('on');
            editBadge.textContent = '편집 모드: OFF';
            editBadge.classList.remove('on');
        }
    }

    // =========================
    // 10. 초기 로드
    // =========================

    function init() {
        currentLayout = loadLayoutOrDefault(currentRoomKey);
        renderNameInputs();
        currentAssignments = loadAssignments(currentRoomKey) || {};
        updateEditModeUI();
        drawRoom();
    }

    init();
</script>
</body>
</html>

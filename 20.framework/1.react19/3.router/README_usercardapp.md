
# React 실습 예제 발전 과정 설명서  
## Card List → Post → Comments 로 확장해 나가기

이 문서는 **React를 처음 배우는 학습자**를 대상으로,  
하나의 예제가 **어떤 이유로, 어떤 개념을 사용하며 단계적으로 확장되는지**를 설명합니다.

본 예제는 단순한 코드 나열이 아니라,  
**“왜 이 시점에 이 기능이 필요한가?”**를 이해하는 것을 목표로 합니다.

---

## 1단계: Card List (리스트 + 카드뷰)

### 🎯 목표
- React의 가장 기본적인 렌더링 흐름 이해
- 데이터 배열 → 화면 렌더링
- 컴포넌트 분리 개념 익히기

### 🧩 도입 개념
- `useState`
- `map()`을 이용한 리스트 렌더링
- `props`
- 컴포넌트 분리 (`UserCard`, `PostCard`)

### 💡 왜 카드뷰인가?
- 단순 `<li>` 리스트보다 **UI 구조를 명확히** 보여줌
- “하나의 데이터 = 하나의 컴포넌트” 개념이 명확
- 이후 **디테일 페이지로 확장하기 쉬움**

### 🔍 이 단계에서 배우는 핵심
- React는 **데이터(state)가 바뀌면 화면이 다시 그려진다**
- 부모 컴포넌트가 데이터를 관리하고, 자식은 표현만 담당

---

## 2단계: Post 리스트 (라우터 도입)

### 🎯 목표
- 여러 화면을 가진 SPA 구조 이해
- URL에 따라 화면이 바뀌는 구조 학습

### 🧩 도입 개념
- `react-router-dom`
- `createBrowserRouter`
- `Link`
- `useParams`

### 💡 왜 라우터가 필요한가?
- 앱이 커질수록 “한 화면”으로는 한계
- `/users`, `/posts` 같은 **의미 있는 URL** 필요
- 새로고침해도 상태가 유지되는 SPA 구조 이해

### 🔍 이 단계에서 배우는 핵심
- React 앱도 “페이지 전환”이 가능하다
- 실제로는 **페이지 이동이 아니라 컴포넌트 교체**

---

## 3단계: Post Detail (상세 페이지)

### 🎯 목표
- 리스트 → 상세 화면 흐름 이해
- URL 파라미터 기반 데이터 선택

### 🧩 도입 개념
- `useParams`
- 조건부 렌더링
- 캐시 개념 (`sessionStorage`)

### 💡 왜 Detail 페이지를 분리하는가?
- 리스트는 “요약 정보”
- 상세 페이지는 “집중해서 읽는 정보”
- 실무 UX 패턴 그대로 학습

### 🔍 이 단계에서 배우는 핵심
- URL 파라미터는 **상태의 한 종류**
- 동일한 데이터라도 **보여주는 맥락에 따라 UI는 달라진다**

---

## 4단계: Comments 로드 (Effect 도입)

### 🎯 목표
- 외부 데이터(API)와 React 상태 동기화
- 비동기 흐름 이해

### 🧩 도입 개념
- `useEffect`
- `fetch`
- 로딩 상태 / 에러 상태
- 조건부 렌더링

### 💡 왜 Comments는 Detail에서 불러오는가?
- 모든 데이터를 한 번에 불러오면 비효율적
- “필요한 시점에만 로드”하는 구조 학습
- 실제 서비스의 API 호출 패턴과 동일

### 🔍 이 단계에서 배우는 핵심
- `useEffect`는 **외부 시스템(API)과 연결하기 위한 도구**
- 로딩 / 성공 / 실패 상태를 분리해서 생각해야 한다

---

## 5단계: 상태 설계와 경고(Warning) 이해

### 🎯 목표
- React 경고 메시지의 의미 이해
- “동작한다”와 “잘 만든 코드”의 차이 인식

### 🧩 도입 개념
- cascading render
- StrictMode
- 상태 초기화 vs 외부 동기화

### 💡 왜 경고가 발생하는가?
- `useEffect` 안에서 즉시 `setState`를 여러 번 호출
- React는 이를 “불필요한 렌더 가능성”으로 판단

### 🔍 중요한 인식
- 경고 ≠ 즉시 버그
- 하지만 **구조적 개선 신호**일 수 있음

---

## 6단계: 실무 관점에서의 최소 안전장치

### 🎯 목표
- 실제 서비스에서도 안전한 코드 구조 이해

### 🧩 도입 개념
- `AbortController`
- 요청 취소
- 레이스 컨디션 방지

### 💡 왜 AbortController를 쓰는가?
- 빠른 라우트 이동 시 이전 요청이 늦게 도착할 수 있음
- 언마운트 후 setState 방지
- 실무에서 매우 흔한 문제

---

## 전체 흐름 요약

| 단계 | 핵심 학습 |
|----|---------|
| Card List | state / props / map |
| Post List | Router / SPA |
| Detail | URL Params / UX |
| Comments | Effect / Fetch |
| Warning | React 철학 |
| 안정화 | 실무 패턴 |

---

## 이 예제가 교육적으로 좋은 이유

- 하나의 코드가 **점진적으로 성장**
- 매 단계마다 “왜 필요한지” 명확
- 실무 구조와 거의 동일
- 이후 Context, React Query, 상태관리로 자연스럽게 확장 가능

---

## 다음 확장 방향 (선택)

- React Query로 데이터 관리
- Context로 Users / Posts 전역 공유
- Pagination / Infinite Scroll
- 실제 백엔드 API 연결

---

> 이 예제의 핵심 메시지:  
> **React는 기능을 한 번에 배우는 게 아니라,  
> “필요해지는 순간”에 하나씩 추가하면서 이해하는 프레임워크다.**
